# Linux 内存管理机制

## 为什么需要内存管理？

在计算机系统中，内存是一种紧缺和宝贵的资源，程序必须载入内存之后才能执行。以前内存空间不够大时，应用程序的数量受到限制，甚至当程序运行时所需内存超过物理内存时程序无法执行。现代操作系统通过引入虚拟内存解决了这个问题。

虚拟内存就是让一个程序的代码和数据在还没有全部载入内存时就可以运行。运行过程中，当执行到未载入内存的代码，或者要访问到还没有载入内存的数据时，虚拟内存管理器就会把这部分代码或数据从硬盘载入内存。而且通常情况下，虚拟内存管理器会先将内存中某些代码或数据置换到硬盘，为即将载入的代码或数据腾出空间。

因为在内存和硬盘之间的数据传输相对于代码执行来说，是很慢的操作，因此虚拟内存管理器在保证工作正确的前提下，会考虑效率因素，比如需要优化指环算法，避免马上要执行的代码或马上要访问的数据被换出内存，而很久没访问的代码或数据却驻留在内存中。另外还需要将驻留在内存中的各个进程的代码或数据维持在一个合理的数量上，并根据该进程的性能表现动态调整此数量，使得程序运行时涉及的磁盘 I/O 次数尽可能少。

## 内存管理机制的组成

Linux 内存管理机制主要由两部分组成，一个部分负责物理内存的申请和释放，物理内存的申请和释放的最小单元称为 “页”。另一个部分负责处理虚拟内存，其操作主要包括虚拟地址空间与实际存储空间的映射，物理内存页和磁盘页之间的置换。

### 进程的内存布局

一个32位的 Linux 进程的地址空间为 4GB，其高位 1G 空间留给内核，低位 3GB 则为用户地址空间使用。

![](https://github.com/Rjerk/learning-notes/blob/master/img/LinuxMemoryManagement0.png?raw=true)

用户地址空间进一步被划分为程序代码区、数据区（包括初始化数据区 DATA 和未初始化数据区 BBS）、堆和栈。

![](https://github.com/Rjerk/learning-notes/blob/master/img/LinuxMemoryManagement1.png?raw=true)

从图中可以看出，在用户地址空间，自底向上为：

- 程序代码区

代码区中存放应用程序的机器代码，运行过程中不能被修改，所以内存为只读，且大小固定。

- 数据区

先是初始化数据区 DATA，然后是未初始化数据区 BBS。

数据区中存放了应用程序中的全局数据、静态数据以及常量字符串等。数据区大小也是固定的。

初始化数据区存放的是在编译器能就知道的由程序设定初始值的全局变量以及静态变量等。这些初始值必须保持在最终生成的二进制文件之中，并且在程序运行时会原封不动地将这个区域映射到进程的初始化区域。即二进制文件在这块区域的大小和进程虚拟地址空间中的初始化区域一样大，而且排列和对应地址的值也一样。

未初始化数据区则不一样，如果一个全局变量或者静态变量在源代码文件中没有初始值，那么在程序启动后，在第一次被赋值之前，其初始值为0。但在最终生成二进制文件时，这些未初始化数据区并不会像初始化数据区一样占据对应变量总大小的区域，而是用一个值来记录其大小。

比如一个程序的代码指令有 100KB 大小，初始化数据有 100KB，未初始化数据有 150KB 大小，那么在最终生成的二进制文件中，代码区有 100KB，紧接着初始化区域有 100KB，然后是一个 4 字节大小的空间，存储一个整数值，为 150 x 1024，表示其大小为 150KB。这样可以节省空间。但是在对应这一块区域的进程虚拟地址空间的未初始化区域，其大小必须为 150KB，只有这样，程序在运行时才会真正访问到这些变量中的每一个。所以程序启动时，检测到二进制文件中未初始化数据区的值为 150 x 1024，系统会自动开辟一个 150KB 的大小区域作为进程的未初始化区域并用 0 来初始化这块区域。

- 堆

堆从未初始化数据区开始向上动态增长，增长过程中虚拟地址变大。

堆是应用程序在运行过程中动态申请的内存空间，如开发人员调用 malloc() 或 new 动态生成对象或开辟内存空间，最终会调用系统调用 brk() 来动态调整数据区的大小。当动态内存区使用完毕，可以调用 free() 或 delete 来释放内存空间，也是调用 brk() 来调整数据区的大小。

- 栈

栈从高位地址开始向下增长，增长过程中虚拟地址变小。

栈用来存放函数的传入参数、临时变量以及返回地址等数据，这些数据占用内存的增长和缩减是由于函数的调用与返回，无需开发人员的参与，没有内存泄漏的危险。

### 物理内存管理

物理内存是用来存放代码指令以及供代码指令操作的数据的最终场所。Linux 系统使用页分配器（page allocator）来管理物理内存页框，页分配器负责分配和回收所有的物理内存页框。

页分配器的核心算法称为 “伙伴算法”，这个算法的思想是每个物理内存区域都会有一个与之相邻的 “伙伴区域”。

当有两个区域被回收，会被合并为一个区域。进一步，当这个被合并区域的相邻区域也被回收后，它们会继续合成一个更大的区域。

当有物理内存分配请求到达时，页分配器会检查有没有大小一致的区域，如果有则直接用找到的匹配区域满足请求，如果没有回找到一个更大的区域。并继续划分，知道分出的区域能够满足这一请求。

这个算法用一个链表来记录空闲的物理内存区域，对每个大小相同的空闲内存区，会有一个链表来将它们串联起来。这些区域的大小都是 2 的某次幂，比如 1，2，4，8 ...

![](https://github.com/Rjerk/learning-notes/blob/master/img/LinuxMemoryManagement2.png?raw=true)

如上图，当有一个 8KB 的请求到达，当前最小可供分配区域为 64KB，会先分为两个 32KB 大小的区域，然后将低位的 32KB 区域分为两个 16KB 大小的区域，再将低位的 16KB 大小区域分为两个 8KB 大小的区域，然后分配高位的 8KB 满足请求。

### 虚拟内存管理

虚拟内存管理器的主要任务是维护应用程序的虚拟地址空间的使用信息，如哪些空间被使用，对应在硬盘的哪个区域。

还有一个重要功能是调页，如在程序访问某些未调至物理内存的数据时，虚拟内存管理器负责定位并置换入物理内存。如果物理内存当前没有空闲区域，还需将其中的某些页先换出去。

#### 维护虚拟地址空间信息

Linux 使用虚存段 vma （virtual memory area）来表示进程中一段连续的虚拟地址空间。vma 用数据结构 vm_area_struct 来表示：

```
struct vm_area_struct {
    struct mm-struct* vm_mm; /*虚存段参数*/
    unsigned long vm_start; /*虚存段始址*/
    unsigned long vm_end; /*虚存段末址*/
    pgprot_t vm_page_prot;
    unsigned short vm_flags;
    /*按地址分叉的 vma 的 AVL 树*／
    shrot vm_avl_height;
    struct vm_area_struct* vm_avl_left;
    struct vm_area_struct* vm_avl_right;
    /*按地址分叉的 vma 链接指针*／
    struct vm_area_struct* vm_next;
    /*或是在一个结点区双向环链表中，或在共享内存区映射表中，或未用*／
    struct vm_area_struct* vm_next_share;
    struct vm_area_struct* vm_prev_share;
    /*用于共享内存*／
    struct vm_operations_struct vm_ops; ／*封装的操作如 open， close*／
    unsigned long vm_offset; /*相对文件中共享内存起点的位移*／
    struct inode* vm_inode; /*指向文件 inode 或 NULL*／
    unsigned long vm_pte;
};
```

进程通常占用各级 vma，分别用于代码段、数据段、堆栈段等。

当此结构体的个数不超过 32 个时，这些结构体被组织为一个链表结构；当超过 32 个时，则被组织为一个二叉平衡树时，以方便提高查询速度。

当程序通过某个指针访问某个数据时，系统会查询这个 vm_area_struct 二叉平衡树，如果没有找到，则判断该指针的地址还没分配，造成一个非法的指针访问。

#### 用于虚拟内存的调页策略

当缺页中断发生时，需要将页从磁盘读入内存，由于缺页中断带来巨大的软件开销，所以希望缺页中断发生的频率最小。这类开销包括决定置换哪个或者哪些驻留页以及交换页所需的 I/O 操作。

此外，在页 I/O 操作中，操作系统还必须调度另一个进程运行，导致进程切换，所以也希望通过适当的策略，使得进程在执行时，访问一个未命中的页中的字的可能性最小。

在下面的策略中，不存在一种绝对的最佳策略，任何特定策略的总性能取决于内存大小、内存和外存的相对速度、竞争资源的进程大小和数目以及单个程序的执行情况等。

##### 读取策略

读取策略确定一个页何时读入内存，常用的两种方法是请求分页和预先分页。

- 请求分页

只有当访问当某页中的一个单元时才将该页读入内存。

当一个进程启动时，会在一段时间内出现大量的缺页中断，随着越来越多的页被取出，局部性原理表明大多数将来访问的页都是最近读取的页，因此一段时间后错误会逐渐减少，缺页中断数目会变得很少。

- 预先分页

预先分页读取的页并不是缺页中断请求的页。如果一个进程的页被连续存储在辅存中，则一次读取许多连续的页比隔一段时间读取一页会更有效。

如果大多数额外读取的页没有引用到，则此策略是低效的。

当进程第一次启动，或发生缺页中断时也可以采用此策略。

##### 放置策略

放置策略决定一个进程块驻留在物理内存什么地方。对于纯粹的分页或段页式的系统，如何放置通常没有什么关系，因为地址转换硬件和内存访问硬件可以以相同效率为任何页框组合执行它们的功能。

##### 置换策略

置换策略用于处理在必须读取一个新页以处理一次缺页中断时，应该置换内存的哪一页，其目标为移出内存中最近最不可能访问的页。根据局部性原理，最近的访问历史和最近将要访问的模式之间有很大相关性。

关于置换策略的一个约束：内存中的某些页框可能被锁定，那它就不能被置换。锁定是通过给每个页框关联一个 lock 位实现的，这一位可以包含在页框表和当前页表中。

###### 基本算法

- 最优算法（OPT）

OPT 策略选择置换下次访问距当前时间最长的那些页，这种算法能导致最少的缺页，但我们无法预知将来，所以不可能实现。但可以作为一种标准衡量其他算法的性能。

- 最近最少使用算法 （LRU）

该策略置换内存中上次使用距当前最远的页。其性能接近于 OPT 策略，问题在于难于实现。

- 先进先出算法（FIFO）

一种简单的策略，把分配给进程的页框看做一个循环缓存区，按循环方式移动页。其隐含逻辑是置换内存中时间最长的页：很久前读入内存的页，可能再也不会用到了。这种推断常常是错误的，所以该策略性能较差。

- 时钟算法

该策略给每一个页框关联一个附加位，或称为使用位。当某一页首次装入内存，将该页框的使用位置为 1；当该页随后被访问到时，它的使用位也会被置为 1。

对于页面置换算法，用于置换的候选页框集合被看做是一个循环缓冲区，并且有一个指针与之相关联。当一页被置换时，该指针被设置为指向缓冲区中的下一页框。当需要置换一页时，操作系统扫描缓冲区，以便找到使用位被置为 0 的一页框。每遇到一个使用位为 1 的页框时，操作系统就将该位重新置为 0。如果在这个过程开始时，缓冲区中所有页框的使用位均为 0，则选择遇到的第一个页框置换；如果所有页框的使用位均为 1，则指针在缓冲区中完整地循环一周，把所有使用位置为0，并停留在最初的位置上，置换该页框中的页。

可见，该策略类似于 FIFO，不同的是时钟策略中使用位为 1 的页框被跳过。该策略之所以被称作时钟策略，是因为可以把页框形象地想象在一个环中。

###### 页缓冲


##### 驻留集管理



##### 清除策略



#### 装入控制




### 虚拟地址映射为物理地址

当程序的通过指针访问数据，其指针本质上是一个虚拟地址值，必须先被转换为物理地址，才能访问其指向的数据。

Linux 使用三层表结构将虚拟地址映射为物理地址：

1. 页目录：一个活动进程有一个页目录，页目录为一个页的大小。页目录中的每一项都指向页中间目录中的一页。
2. 页中间目录：页中间目录可能跨越多个页，其中每一项都指向页表中的一页。
3. 页表：页表可以跨越多个页，每个页表项指向进程中的每个虚拟页面。

为使用这个三级表结构，Linux 的虚拟地址被看做由 4 个域组成。如图：

![](https://github.com/Rjerk/learning-notes/blob/master/img/LinuxMemoryManagement3.png?raw=true)

最左边的域是页目录的索引，第二个域是页中间目录的索引，第三个域作为页表的索引，第四个域给出在内存中被选中页中的偏移量。
