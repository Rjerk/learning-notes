# 带外数据

带外数据也称为经加速数据。当一个连接的某端发生了重要的事情，希望快速通告其对端，就会用到带外数据。这里的 “快速” 是指该通告应该在已经排队等待的任何 “普通” 数据中具有更高优先级。带外数据被映射到已有连接中。

UDP 没有实现带外数据。

## TCP 带外数据

TCP 没有真正的带外数据，而是提供了紧急模式。

### 发送端

当进程往一个 TCP 套接字写出 N 字节的数据，这些数据会被排队在发送缓冲区中等待发送到对端。当用到带外数据时：

```
send(fd, "a", 1, MGS_OOB);
```

TCP 会把这个数据放置在发送缓冲区的下一个可用位置，并把该连接的 TCP 紧急指针设置为下一个可用位置，并把带外字节标记为 OOB。

```
-------------------------------------
1 |    ...       | N |  OOB  |
-------------------------------------
^                       ^      ^
要发送的              要发送的  TCP 紧急指针
第一个字节           最后一个字节
```

发送端 TCP 将为待发送的下一个分界在 TCP 首部中设置 URG 标志，并把紧急偏移 (urgent offset) 设置为带外字节的下一个字节。当然该分节可能不含标记为 OOB 的那个字节，因为其发送取决于在套接字发送缓冲区中先于它的字节数、TCP 准备发送给对端的分节大小以及对端通告的当前窗口大小。

所以当 TCP 首部指出发送端已经进入紧急模式（其 URG 标志被设置），但是紧急指针所指的实际数据字节却不一定随同送出。

如果发送端 TCP 因为流量控制而暂停发送紧急数据，紧急通知却可以不伴随任何数据发送。这是应用进程使用 TCP 紧急模式的一个原因：即使数据的流动会因为 TCP 的流量控制而停止，但紧急通知却可以无障碍地发送到对端 TCP。

如果发送多字节的带外数据，如：

```
send(fd, "abc", 3, MSG_OOB);
```

此例中 TCP 的紧急指针会指向最后那个字节紧后的位置，即 'c' 会被认为是带外字节。

### 接收端

当收到一个设置了 URG 标志的分节时，接收端 TCP 检查紧急指针，确认它是否指向新的带外数据。发送端 TCP 往往发送多个有 URG 标志且紧急指针指向同一个数据字节的分节，这些分节只有第一个到达的会通知接受端进程有新的带外数据到达。

接受进程被通知后：

1. 内核给接受套接字的属主进程发送 SIGURG 信号（前提是接受进程或其他进程曾调用 fcntl 或 ioctl 为套接字建立了属主，而且属主进程为该信号建立了信号处理函数）。
2. 如果接受进程阻塞在 select 调用中等待这个套接字描述符出现一个异常条件，select 调用就返回。

当有新的紧急指针到达，不论紧急指针指向的实际数据字节是否已经到达接收端 TCP，这两个潜在通知进程的动作就发生。只有一个 OOB 标记，如果新的 OOB 字节在旧的 OOB 字节被读取之前就到达，旧的 OOB 字节就被丢弃。

当紧急指针指向的实际数据字节到达接收端 TCP 时，该数据字节既可能被拉出带外，也可能留在带内（即在线留存）。

SO_OOBINLINE 套接字选项默认情况下是禁止的，对于这样的接受端套接字，该数据字节并不放入套接字接受缓冲区，而是被放入一个独立的单字节带外缓冲区。接受进程从这个单字节带外缓冲区读入数据的唯一方法是指定 MSG_OOB 标志调用 recv、recvfrom 或 recv_msg。如果新的 OOB 字节在旧的 OOB 字节被读取前到达，旧的 OOB 字节就被丢弃。

如果开启了 SO_OOBINLINE，那么 TCP 紧急指针指向的实际字节将被留在通常的套接字接受缓冲区内，接受进程不能指定 MSG_OOB 标记读入该字节，而是通过检查连接的带外标记 (out-of-band mark) 以获取何时访问到这个字节。

一些错误：
1. 如果接收端进程读入带外数据（指定 MSG_OOB标志），而对端尚未发送任何带外数据，则读入操作返回 EINVAL。
2. 如果接收端进程被告知有带外字节的到来（SIGURG 或 select），当读入该字节但字节未到达，读入操作返回 EWOULDBLOCK。
3. 如果接受进程试图多次读入同一个带外字节，则读入操作返回 EINVAL。
4. 如果接受进程开启了 SO_OOBINLINE，又试图通过指定 MSG_OOB 标志读入带外数据，读入操作将返回 EINVAL。


## sockatmark 函数

每收到一个带外数据，就有一个与之关联的带外标记，即发送进程发送带外数据时该字节在发送端普通数据流中的位置。读套接字时，接收端通过调用 sockatmark 函数确定是否处于带外标记。

```
#include <sys/socket.h>
int sockatmark(int sockfd);
// 处于带外标记返回 1，不处于带外标记返回 0，出错返回 -1.
```

带外标记的 5 个特性:
1. 带外标记总是指向普通数据最后一个字节后面紧后的位置。([tcprecv04.cpp](https://github.com/Rjerk/snippets/blob/master/unp/oob/tcprecv04.cpp), [tcpsend04.cpp](https://github.com/Rjerk/snippets/blob/master/unp/oob/tcpsend04.cpp))
  若带外数据在线接收，如果下一个待读入的字节是使用 MSG_OOB 标志发送的，则 sockatmark 返回真；若没有开启 SO_OOBINLINE，如果 下一个待读入的字节是跟在带外数据后发送的第一个字节，则 sockatmark 返回真。 
2. 读操作总是停在带外标记上。
  如果接受缓冲区中有 100 个待读入的字节，但是在带外标记前有 5 个字节，而进程执行一个请求 100 字节的 read 操作，那么返回的是带外标记之前的 5 个字节。这种在带外标记上强制停止读操作的做法使得进程可以调用 sockatmark 确定缓冲区指针是否处于带外标记。
3. 即使因为流量控制而停止发送数据，TCP 仍然发送带外数据的通知（即它的紧急指针）。([tcprecv05.cpp](https://github.com/Rjerk/snippets/blob/master/unp/oob/tcprecv05.cpp), [tcpsend05.cpp](https://github.com/Rjerk/snippets/blob/master/unp/oob/tcpsend05.cpp))
4. 在带外数据到达之前，接收进程可能被通知说发送端已经发送了带外数据。如果接着指定 MSG_OOB 调用 recv，而带外数据却未到达，则 recv 返回 EWOULDBLOCK 错误。
5. 如果在接收进程读入某个现有带外数据前有新的带外数据到达，则先前的标记丢失。([tcprecv06.cpp](https://github.com/Rjerk/snippets/blob/master/unp/oob/tcprecv06.cpp), [tcpsend06.cpp](https://github.com/Rjerk/snippets/blob/master/unp/oob/tcpsend06.cpp))

## TCP 带外数据小结

带外数据实际上向接收端传达了三个不同的信息：
1. 发送端进入紧急模式这个事实。本通知可能导致接收端进入某种特殊处理模式，以处理接受的任何后继数据。
2. 带外字节的位置。即带外标记。
3. 带外字节的实际值。带外字节可以是任何 8 位值。

相关问题：
1. 每个连接只有一个 TCP 紧急指针。
2. 每个连接只有一个带外标记。
3. 每个连接只有一个单字节的带外缓冲区。

如果带外数据是在线接受的，那么当新的带外数据到达时，先前的带外字节并未丢失，但是它们的标记却因为新的标记取代而丢失了。

带外数据是否有用取决于应用进程使用的目的。如果目的是告知对端丢弃直到标记处的普通数据，则丢失一个中间带外字节及其相应的标记不会有什么不良后果。如果不丢失带外数据很重要，那么必须在线接受这些数据。