# Linux中的进程控制

## 进程基础

### 进程

进程是计算机中一个执行程序的实体，系统中的每个程序都运行在某个进程的上下文中，这个上下文中通常包括一些资源，如存放在内存中的代码与数据，程序计数器，处理器的状态等。

### PID和PPID

每个进程都有一个唯一的正数进程标识符，简称PID，用来标志和区分进程。

PID 为0的进程通常是调度进程，该进程是内核的一部分，并不执行磁盘的任何程序。

PID 为1的进程通常是init进程，负责在自举内核后启动系统。通常读取与系统有关的初始化文件，并将系统引导到一个状态（比如多用户），而且永远不会终止。

几乎每个进程都是由父进程衍生出来的，每个进程除了有PID 还有PPID，即父进程标识符。我们说几乎，是因为在Linux 系统启动最后阶段内核启动init 进程，该进程读取系统初始化脚本并执行其他的相关程序，因此所有进程都是init 进程的后代。

进程都由init 进程衍生而来，故Linux 中进程模型也叫进程家族树。

在Linux 中，用getpid 和getppid 函数可以返回调用进程的PID 和PPID。

```
#include <sys/types.h>
#include <unistd.h>

pid_t getpid();
pid_t getppid();
```

在命令行中可以使用ps 或top 查看进程：
```
$ pid
   PID TTY          TIME CMD
 43522 pts/6    00:00:00 bash
 43799 pts/6    00:00:00 ps

$ top
Tasks: 254 total,   1 running, 248 sleeping,   4 stopped,   1 zombie
%Cpu(s):  4.5 us,  4.2 sy,  0.0 ni, 91.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  2030464 total,    90196 free,  1242900 used,   697368 buff/cache
KiB Swap:  1046524 total,   716900 free,   329624 used.   544252 avail Mem 

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
  1237 root      20   0  406736  63240  22040 S  2.0  3.1  34:11.50 Xorg        
  1993 linux     20   0 1236728  96400  28660 S  2.0  4.7  25:59.81 compiz
...
```

### 进程的三种状态

进程有以下三种状态：
- 运行态 该时刻进程在CPU 上执行
- 就绪态 可运行，但因为其他进程在运行而等待被调度执行
- 阻塞态 进程被挂起，且不会被调度，除非某种外部事件发生，比如输入或信号到达。

进程状态转换图

![](http://www.bogotobogo.com/Linux/images/process/ProcessState.png)

## 进程的创建、执行和终止

### 进程的创建

有四种主要事件导致进程的创建：

1. 系统初始化

操作系统启动之时，init 进程通常会创建若干进程。有些是前台进程，即同人类交互的进程，有些是后台进程，停留在后台处理如接收邮件、打印机打印服务等进程称为守护进程。

2. 在运行的进程调用进程创建系统调用

一个正在运行的进程经常发出系统调用，以创建一个或多个新进程进行协助工作。

3. 用户请求创建一个进程

在交互式系统中，用户可以同时打开多个窗口，每个窗口都运行一个进程，通过鼠标可以选择一个窗口并与此进程进行交互。

4. 一个批处理作业的初始化

这种情形仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，系统认为有资源可运行另一个作业就会创建一个新的进程并运行其输入队列中的下一个作业。

从技术上看，所有这些情景中，新进程都是由于一个已存在的进程执行了一个系统调用而创建的，这个系统调用通知操作系统创建一个新进程，并指定在该进程中运行的程序。

#### Linux中进程的创建

Linux 中进程的创建分为两步，首先通过fork() 拷贝并创建一个子进程，exec() 负责读取可执行文件并将其载入地址空间开始运行。

Linux 的fork()使用写时拷贝(copy-on-write)实现，它是一种可以推迟甚至无需拷贝的技术。内核并不拷贝整个进程的地址空间，而是让父进程和子进程共享一个拷贝，只有在需要写入时数据才会被复制，从而使得每个进程各自拥有各自的地址空间，这种技术可以避免拷贝大量可能根本不会使用的数据。

##### fork()

```
#include <sys/types.h>
#include <unistd.h>

pid_t fork();
```

父进程调用fork()，如果它修改了一些属于它的变量，这对子进程是不可见的。但是如果某个文件在父进程调用fork() 之前就打开了，在调用fork() 之后，这个文件是可以共享的，即其中一个进程对其进行修改，这些修改对另一个进程而言是可见的。

fork() 调用之后，给子进程返回一个零值，给父进程返回一个非零值，这个非零值是子进程的PID，两个进程通过校验返回值，根据返回值继续执行。

父进程和子进程都是并发执行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流中的指令。我们不能对不同进程中指令的交替执行顺序作任何的假定。

```
#include <sys/types.h>
#include <unistd.h>
#include <cstdio>
#include <cstdlib>

int main()
{
    pid_t pid;
    int x = 1;
    if ((pid = fork()) == 0) { // child
        printf ("child = %d\n", pid);
        exit(0);
    } else if (pid > 0) { // parent
        printf ("parent = %d\n", pid);
        exit(0);
    }
}
```

输出：
```
child = 0
parent = 45802
```

进程之间可以通过管道，信号等机制进行通信，可以见另一篇文章[Linux中进程间通信机制](https://rjerk.github.io/2017/03/23/Linux%E4%B8%AD%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/)。

### 进程的运行

```
#include <unistd.h>

int execve(const char* filename, const char* argv[], const char* envp[]);
// filename: 文件名
// argv: 参数字符串的指针数组
// envp: 环境变量字符串的指针数组
```

可使用execve 函数在当前进程的上下文中运行一个新的程序（而非进程），会覆盖当前进程的地址空间，但没有创建一个进程。新的程序仍有相同的PID，并继承了调用execve函数时已打开的所有文件描述符。

### 进程的终止

进程的终止分为正常和异常两种。

5种正常终止：
1. 在main 函数中返回，等效于调用exit。
2. 调用exit 函数，其操作包括调用各终止处理程序，然后关闭所有标准I/O 流等。
3. 调用_exit 或_Exit 函数。
4. 进程的最后一个线程在其启动例程中执行return 语句。
5. 进程的最后一个线程调用pthread_exit 函数。

3种异常终止：
1. 调用abort，产生SIGABRT 信号。
2. 进程接收到某些信号时，信号可由进程自身、其它进程或内核产生。
3. 最后一个线程对 “取消” 请求作出相应。

```
#include <unistd.h>

void _exit(int status);
```
进程可以使用_exit() 系统调用正常终止，status定义了进程的终止状态，在父进程中用wait() 可获取。调用_exit() 的程序总会正常终止。

```
#include <stdlib.h>

void exit(int status);
``` 
程序一般不会直接调用_eixt() ，而是使用库函数exit()，exit() 会执行的操作如下：
- 调用退出处理程序，其执行顺序与注册顺序相反
- 刷新stdio 流缓存区
- 使用status 提供的值执行_exit() 系统调用

#### 进程的回收

当进程终止时，内核并不把它从系统中清除，而是使进程保持在已终止的状态，直到被父进程回收。当父进程回收子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此该进程不存在。一个已终止但是未回收的进程称为僵尸进程。

如果一个父进程终止，内核会安排init进程称为其子进程的养父。

进程可以调用wait 函数和waitpid 函数等待其子进程终止：

```
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int* status_sp);
// 成功返回子进程的PID，失败返回-1.

pid_t waitpid(pid_t pid, int* status_sp, int options);
// 成功返回子进程的PID，如果WNOHANG，返回0，其他错误返回-1.
// <wait.h>中定义#define WNOHANG 1，指如果等待集合中的任何子进程都没终止，就立即返回0.
```

