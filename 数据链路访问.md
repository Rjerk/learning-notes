# 数据链路访问

大多数操作系统为应用程序提供访问数据链路层的功能，这种功能提供如下能力：
- 监视由数据链路层使用的分组，使得如 tcpdump 这样的程序能在普通计算机系统上运行，而无需使用专门的硬件来监视分组。如果结合使用网络接口进入混杂模式的能力，甚至能监视本地电缆上的所有分组。
- 能够作为普通应用进程而不是内核的一部分运行某些程序。

UNIX 访问数据链路的 3 个办法：BSD 的分组过滤器 BPF、SVR4 的数据链路提供者接口 DLPI 和 Linux 的 SOCK_PACKET 接口。

## BPF (BSD Packet Filter)

在支持 BPF 的系统上，每个数据链路驱动程序都在发送一个分组之前或接收一个分组之后调用 BPF。

BPF 的强大威力在于它的过滤能力，打开一个 BPF 设备的每个应用程序可以装载各自的过滤器，这个过滤器随后由 BPF 应用于每个分组。

BPF 使用以下 3 个技术来降低开销：
- BPF 过滤在内核中进行，这样就把 BPF 到应用进程的数据复制量减少到最小。
- 由 BPF 传递到应用进程的只是每个分组的一段定长部分。这个长度称为捕获长度或快照长度。因为大多数应用进程只需要分组首部而无需分组数据。这种技术能减少 BPF 复制到应用进程的数据量。
- BPF 为每个应用进程分别缓冲数据，只有当缓冲区已满或读超时期满时，该缓冲区的数据才复制到应用进程。如此缓冲的目的是为了减少系统调用的次数。

BPF 使用双缓冲技术，为每个进程维护两个缓冲区，在其中一个缓冲区中的数据被复制到应用进程期间，另一个缓冲区被用于装填数据。

为访问 BPF，必须打开一个关闭着的 BPF 设备，然后就可以使用 `ioctl` 命令来设置该设备的特征，如装载过滤器、设置读超时等，然后就可以使用 `read` 和 `write` 执行 I/O。

## DLPI (Datalink Provider Interface)

DLPI 有两种打开方式：一种方式是应用进程先打开一个统一的伪设备，再使用 DLPI 的 `DL_ATTACH_REQ` 往其上附接某个数据链路（即网络接口）；另一种方式是应用进程直接打开某个网络接口设备。

不管以哪种方式打开 DLPI，通常尚需为提高操作效率而压入 2 个流模块：在内核中进行分组过滤的 pfmod 模块和为应用进程缓冲数据的 bufmod 模块。pfmod 支持使用伪机器的内核中过滤，bufmod 则通过支持捕获长度和读超时减少数据量和系统调用的次数。

## Linux: SOCK_PACKET 和 PF_PACKET

Linux 先后有两个从数据链路层接收分组的方法，较旧的方法是创建类型为 `SOCK_PACKET` 的套接字，该方法可用面较广，但是缺乏灵活性。较新的方法是创建协议族 `PF_PACKET` 的套接字，该方法引入了更多的过滤和性能特性。

必须有足够权限才能创建，调用 `socket` 的第二个参数可以是 `SOCK_DGRAM`，表示扣除链路层首部的 cooked 分组，也可以是 `SOCK_RAW`，表示完整的链路层分组（以太网帧）。第三个参数必须是指定以太网帧类型的某个非 0 值。

Linux 的数据链路访问方法相比 BPF 和 DLPI 存在以下差别：
- 不提供内核缓冲，只有新的方法才能提高内核缓冲。
- 较旧的方法不提供针对设备的过滤。

## libcap 和 libnet

libcap 是访问操作系统所提高的分组捕获机制的分组捕获函数库，与实现无关，目前只支持分组的读入。tcpdump 就使用该函数库。

libnet 函数库提供构造任意协议的分组并将其输出到网络中的接口，它以实现无关的方式提供原始套接字访问方式和数据链路访问方式。