# Observer 模式

## 意图

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维护一致性而使各类紧密耦合，因为这样降低了它们的可重用性。

一个目标（subject）可以有任意数量的依赖它的观察者（observer），一旦目标的状态发生改变，所有的观察者都得到通知。作为对这个通知的相应，每个观察者都将查询目标以使其状态与目标的状态同步。

## 适用性

可以使用 Observer 模式的情况：
- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在独立的对象中以使它们可以独自地改变和复用。
- 当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。
- 当一个对象必须通知其他对象，而它又不能假定其它对象是谁。即不希望这些对象是紧密耦合的。

## 结构

![](https://github.com/Rjerk/learning-notes/blob/master/img/Observer.png?raw=true)

- Subject
  - 目标知道它的观察者。可以有任意多个观察者观察同一目标。
  - 提供注册和删除观察者目标的接口。
- Observer
  - 为那些在目标发生改变时需获得通知的对象定义一个更新接口。
- ConcreteSubject
  - 将有关状态存入各 ConcreteSubject 对象。
  - 当它的状态发生改变时，向它的各个观察者发出通知。
- ConcreteObserver
  - 维护一个指向 ConcreteSubject 对象的引用。
  - 存储有关状态，这些状态应该与目标的状态保持一致。
  - 实现 Observer 的更新接口以使自身状态和目标保持一致。 

## 效果

Observer 模式允许你独立地改变目标和观察者，可以单独复用目标对象而无需同时复用器观察者，反之亦然；也使你在不改变目标和其他的观察者前提下增加观察者。

优缺点：

1. 目标和观察者之间的抽象耦合。

一个目标所知道的仅仅是它有一系列观察者，每个都符合抽象的 Observer 类的简单接口。目标不知道任何一个观察者属于哪个具体的类，使得目标和观察者之间的耦合是抽象的和最小的。

因为目标和观察者不是紧密耦合，它们可以属于一个系统中的不同层次。一个低层次的目标对象可以与一个高层次的观察者通信，这样保持了系统层次的完整性。

2. 支持广播通信

通知被广播给所有已向该目标对象登记的有关对象。目标对象不关心有多少观察者对它感兴趣，唯一的责任就是通知它的观察者。这使得添加和删除观察者更加自由，而处理还是一个通知取决于观察者。

3. 意外的更新

因为一个观察者并不知道其他观察者的存在，它可能对改变目标的最终代价一无所知。在目标上一个看似无害的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新，如果依赖准则的定义或维护不当，常常引起错误的更新。

## 实现

实现依赖机制：

1. 创建目标到其观察者之间的映射

  可以显示地在目标中保存对观察者们的引用，然而当目标很多而观察者太少时，这样存储可能代价太高。

  可以用一个关联查找机制来维护目标到观察者之间的映射，这样一个没有观察者的目标不产生存储开销。但另一方面，却增加了访问观察者的开销。是以时间换取空间的方法。

2. 观察多个目标

  一个观察者可能依赖于多个目标，所以必须扩展 Update 接口以使得观察者知道是哪个目标送来的通知。

  目标对象可以将自己作为 Updata 操作的一个参数，让观察者知道去检查哪个目标。

3. 谁触发更新

  - 让目标对象的状态设定操作在改变目标对象的状态后自动调用 Notify。

    优点是客户不需要记住要在目标对象上调用 Notify。

    缺点是多个连续的操作会产生多个连续的更新，使得效率较低。

  - 让客户在适当时调用 Notify。

    优点是客户可以在一系列的状态改变完成后再一次性地触发更新，避免了不必要的中间更新。

    缺点是客户增加了触发更新的责任。容易忘记调用 Notify，导致出错。

4. 对已删除目标的悬挂引用

  删除一个目标时应注意不要在观察者中遗留对该目标的悬挂引用。可以在一个目标被删除时，让它通知它的观察者们对它的引用复位。

5. 在发出目标通知前确保目标的状态自身是一致的

  因为观察者在更新其状态的过程中需要查询目标的当前状态。

  可以用抽象的 Subject 类中的模板方法发送通知来避免这种错误。定义那些子类可以重定义的原语操作，并将 Notify 作为模板方法中的最后一个操作，这样子类重定义了 Subject 的操作时，还可以保证该对象的状态是自身一致的。

6. 避免特定于观察者的更新协议 —— 推/拉模型

  观察者模式的实现经常需要让目标广播关于其改变的其他一些信息。目标将这些信息作为 Updata 操作一个参数传递出去。这些信息的量可大可小。

  一种极端情况下，目标向观察者发送关于改变的详情信息，而不管它们需要与否，我们称其为推模型（push model）；另一种极端情况下，目标除最小通知外什么也不送出，而在此之后由观察者显式地向目标询问细节，称其为拉模型（pull model）。

  推模型假定目标知道一些观察者的需要的信息，而拉模型强调的是目标不知道它的观察者。

  推模型可能使得观察者相对难以复用，因为目标对观察者的假定可能并不总是正确的。拉模型可能效率较差，因为观察者对象需要在没有目标对象帮助下确定什么改变了。

7. 显示地指定感兴趣的改变

  可以扩展目标的注册接口，让各个观察者注册为仅对特定事件感兴趣，以提高更新的效率。

8. 封装复杂的更新语义

  当目标和观察者之间的依赖关系特别复杂时，可能需要一个维护这些关系的对象，称其为更改管理器（ChangeManager）。其目的是尽量减少观察者反映其目标的状态变化所需的工作量。

  ChangeManager 有三个责任：
  - 将一个目标映射到它的观察者并提供一个接口来维护这个映射，这样就不需要由目标来维护对其观察者的引用。反之亦然。
  - 定义一个特定的更新策略。
  - 根据一个目标的请求，更新所有依赖于这个目标的观察者。

9. 结合目标类和观察者类

用不支持多重继承的语言书写的类库通常不单独定义 Subject 和 Observer 类，而是将它们的接口结合到一个类中。可以定义一个既是一个目标又是一个观察者的对象，而不需要多重继承。

一个 Observer 的简单实现：[Observer.cpp](https://github.com/Rjerk/snippets/blob/master/design-patterns/Observer.cpp)

## 相关模式

- Mediator：通过封装复杂的更新语义，ChangeManager 充当目标和观察者之间的中介者。
- Singleton：ChangeManager 可使用 Singleton 模式来保证它是唯一的并且是可全局访问的。