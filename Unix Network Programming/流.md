# 流

X/Open 传输接口（X/Open Transport Interface，XTI）和网络协议通常就如终端 I/O 系统那样使用流系统（streams system）实现。

## 流系统概貌

流在进程和内核之间提供全双工的连接。

流头由一些内核例程构成，应用进程针对流描述符执行系统调用时这些内核例程将被激活。

进程可以在流头和驱动程序之间动态增删中间处理模块，这些模块对顺着一个流上行或下行的消息施行某种类型的过滤。

```
                                  进程
                                   ↑ 
                         ————————————————————
                                   ↓
        进程                --------------
         ↑                  |    流头    |
———————————————————         --------------
         ↓                        ↑ ↓
    -----------             --------------
    |   流头   |            |   处理模块  |
    -----------             --------------
        ↑ ↓       内核            ↑ ↓         内核
    -----------             --------------
    | 驱动程序 |             |  驱动程序  |
    -----------             --------------
————————————————————     ————————————————————
```

底部的驱动程序不必与某个硬件设备相关联，它可以是一个伪设备驱动程序，即软件驱动程序。

一个流中的某个部件 ———— 流头、所有处理模块和驱动程序 ———— 包含至少一对队列：一个写队列和一个读队列。


```
               进程
                ↑ 
       ————————————————————
                ↓
        ------------------
流头    | 写队列 | 读队列  |
        ------------------
                ↑ ↓
        ------------------
处理模块 | 写队列 | 读队列 |
        ------------------
                ↑ ↓         内核
        ------------------
驱动程序 | 写队列 | 读队列 |
        ------------------
       ————————————————————
```

流消息可划分为高优先级、优先级带和普通三类。优先级共有 256 带，在 0 - 255 之间取值。普通消息位于带 0。流消息的优先级用于排队和流量控制。高优先级不受流量控制的影响。

```
                  优先级带             优先级带
|高优先级消息| → | 255 消息 | → ... → | 1 消息  | → | 普通消息 |
  ↑                                                         ↑
队列头                                                     队列尾
————————————   ————————————————————————————————  ——————————————
   高优先级                   优先级带                  普通   

```

虽然流系统支持 256 个不同的优先级带，网络协议往往只用代表经加速数据的带 1 和代表普通数据的带 0.

## getmsg 函数和 putmsg 函数

沿着流上行和下行的数据由消息构成，而且每个消息含有控制或数据，或都有。

如果在流上使用 `read` 和 `write` 则传送的只是数据。为了让进程能读写数据和控制两部分信息，流系统增加了两个函数：

```
#include <stropts.h>
int getmsg(int fd, struct strbuf* ctlptr, struct strbuf* dataptr, int* flagsp);
int putmsg(int fd, const struct strbuf* ctlptr, const struct strbuf* dataptr, int flags);
// 成功返回非负值，出错返回 -1.
```

`strbuf` 的结构体：

```
struct strbuf {
    int   maxlen; // maximum size of buf.
    int   len; // actual amount of data in buf.
    char* buf; // data.
};
```

`getmsg` 调用时，如果指定的 `flagsp` 指向的整数值为 0，那么返回的是流中的第一个消息（既可能是普通消息，也可能是高优先级消息）。如果为 `RS_HIPRI`，那就等待一个高优先级消息到达流头。如果传递的 `ctlptr` 或 `dataptr` 参数均为非空指针，如果没有控制信息待返回，`getmsg` 就在返回时把 `ctlptr->len` 设置为 -1 作为指示。如果没有数据信息待返回就把 `dataptr->len` 设置为 -1。

使用 `putmsg` 可以发送消息，为指示缺失某信息，可以把 `ctlptr` 指定为空指针，或把 `ctlptr->len` 设为 -1。如果缺失控制消息，则 `putmsg` 产生一个 `M_DATA` 消息；否则根据 `flags` 参数产生一个 `M_PROTO` 或 `M_PCPROTO`（priority control，指高优先级消息）。`flags` 为 0 表示普通消息，为 `RS_HIPRI` 表示高优先级消息。 

## getpmsg 函数和 putpmsg 函数

对不同优先级带的支持：

```
#include <stropts.h>
int getpmsg(int fd, struct strbuf* ctlptr, struct strbuf* dataptr,
            int* bandp, int* flagsp);
int putpmsg(int fd, const struct strbuf* ctlptr, const struct strbuf* dataptr,
            int band, int flags);
```

`getpmsg` 的 `flagsp` 指向的整数可以取值 `MSG_HIPRI`（以读入一个高优先级）、`MSG_BADN`（以读入一个优先级至少为 bandp 指向的整数值的消息）、`MSG_ANY`（以读入任意消息）。函数返回时，`bandp` 指向的整数含有所读入消息的优先级带，`flagsp` 指向的整数含有 `MSG_HIPRI`（如果所读入的是一个高优先级消息）或 `MSG_BAND`（如果所读入的是其他类型消息）。

`putpmsg` 的 `band` 参数必须在 0~255 之间，如果 `flags` 参数为 `MSG_BAND`，那就产生一个所指定优先级带的消息。把 `flags` 设置为 `MSG_BAND` 并把 `band` 设置为 0 等效于调用 `putmsg`。如果 `flags` 为 `MSG_HIPRI`，`band` 就必须为 0，所产生的是一个高优先级消息。

## ioctl 函数

```
#inlcude <stropts.h>
int ioctl(int fd, int request, ... /* void* arg */);
// 成功返回 0，出错返回 -1.
```

处理流时所包含的头文件是不一样的。大约有 30 个 `ioctl` 请求影响流头，每个请求均以 `I_` 开头。

## TPI：传输提供者接口

TCP 是在基于流的系统上套接字和 XTI 通常使用的传输层访问接口。它基于消息，定义了在应用进程和传输层之间沿着流上行和下行交换的消息，包括消息的接口和每个消息执行的操作。

拿编程语言类比，使用套接字或 XTI 好比使用诸如 C 等高级语言编程，直接使用 TPI 好比使用汇编语言编程。
